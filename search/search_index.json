{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMP2001","title":"COMP2001"},{"location":"#comp2001","text":"","title":"COMP2001"},{"location":"Practice%20Problems/Ch10/","text":"Ch10: Improving structure with inheritance Casting in Inheritance Problem Description Create a base class Person with attributes like name and methods like getName() . Create a subclass Student that adds attributes like studentId and methods like getStudentId() . Further extend Student with GraduateStudent , which adds attributes like researchTopic . Demonstrate: Upcasting: Casting a Student object to Person . Downcasting: Casting a Person object back to GraduateStudent safely using instanceof . Code Implementation class Person { private String name ; public Person ( String name ) { this . name = name ; } public String getName () { return name ; } } class Student extends Person { private int studentId ; public Student ( String name , int studentId ) { super ( name ); this . studentId = studentId ; } public int getStudentId () { return studentId ; } } class GraduateStudent extends Student { private String researchTopic ; public GraduateStudent ( String name , int studentId , String researchTopic ) { super ( name , studentId ); this . researchTopic = researchTopic ; } public String getResearchTopic () { return researchTopic ; } } public class CastingDemo { public static void main ( String [] args ) { GraduateStudent grad = new GraduateStudent ( \"Alice\" , 12345 , \"Machine Learning\" ); Person person = grad ; // Upcasting if ( person instanceof GraduateStudent ) { GraduateStudent gradStudent = ( GraduateStudent ) person ; // Downcasting System . out . println ( \"Research Topic: \" + gradStudent . getResearchTopic ()); } } } Inheritance and Collections Problem Description Create a superclass Document with a method printDetails() . Define subclasses WordDocument and Spreadsheet , each with unique attributes. Use a List<Document> to store objects of both subclasses and iterate through the list, invoking printDetails() . Code Implementation import java.util.ArrayList ; abstract class Document { protected String name ; public Document ( String name ) { this . name = name ; } public abstract void printDetails (); } class WordDocument extends Document { private int wordCount ; public WordDocument ( String name , int wordCount ) { super ( name ); this . wordCount = wordCount ; } @Override public void printDetails () { System . out . println ( \"Word Document: \" + name + \", Word Count: \" + wordCount ); } } class Spreadsheet extends Document { private int sheets ; public Spreadsheet ( String name , int sheets ) { super ( name ); this . sheets = sheets ; } @Override public void printDetails () { System . out . println ( \"Spreadsheet: \" + name + \", Sheets: \" + sheets ); } } public class DocumentDemo { public static void main ( String [] args ) { ArrayList < Document > documents = new ArrayList <> (); documents . add ( new WordDocument ( \"Report\" , 1200 )); documents . add ( new Spreadsheet ( \"Budget\" , 3 )); for ( Document doc : documents ) { doc . printDetails (); } } } Method Overloading vs. Overriding Problem Description Create a Calculator class with overloaded calculate() methods: One for int arguments. Another for double arguments. Extend Calculator with a ScientificCalculator subclass, overriding calculate() to include scientific calculations. Code Implementation class Calculator { public int calculate ( int a , int b ) { return a + b ; } public double calculate ( double a , double b ) { return a + b ; } } class ScientificCalculator extends Calculator { @Override public double calculate ( double a , double b ) { return Math . pow ( a , b ); // Exponentiation } } public class CalculatorDemo { public static void main ( String [] args ) { Calculator calc = new Calculator (); System . out . println ( \"Addition (int): \" + calc . calculate ( 3 , 5 )); System . out . println ( \"Addition (double): \" + calc . calculate ( 3.2 , 5.1 )); ScientificCalculator sciCalc = new ScientificCalculator (); System . out . println ( \"Power: \" + sciCalc . calculate ( 2.0 , 3.0 )); } } Deep Inheritance Hierarchies Problem Description Create a superclass Appliance with a turnOn() method. Create a subclass KitchenAppliance with an overridden turnOn() method. Create a further subclass Toaster with additional behavior. Demonstrate method inheritance and overriding. Code Implementation class Appliance { public void turnOn () { System . out . println ( \"Appliance is now on.\" ); } } class KitchenAppliance extends Appliance { @Override public void turnOn () { System . out . println ( \"Kitchen Appliance is now on.\" ); } } class Toaster extends KitchenAppliance { public void toast () { System . out . println ( \"Toasting bread...\" ); } } public class ApplianceDemo { public static void main ( String [] args ) { Appliance appliance = new Appliance (); appliance . turnOn (); KitchenAppliance kitchenAppliance = new KitchenAppliance (); kitchenAppliance . turnOn (); Toaster toaster = new Toaster (); toaster . turnOn (); toaster . toast (); } } Polymorphism with Interfaces Problem Description Define an interface Payment with a processPayment() method. Implement the interface in classes CreditCardPayment and PayPalPayment . Demonstrate polymorphism by using a Payment reference to process payments. Code Implementation interface Payment { void processPayment ( double amount ); } class CreditCardPayment implements Payment { @Override public void processPayment ( double amount ) { System . out . println ( \"Processing credit card payment of $\" + amount ); } } class PayPalPayment implements Payment { @Override public void processPayment ( double amount ) { System . out . println ( \"Processing PayPal payment of $\" + amount ); } } public class PaymentDemo { public static void main ( String [] args ) { Payment payment1 = new CreditCardPayment (); Payment payment2 = new PayPalPayment (); payment1 . processPayment ( 100.50 ); payment2 . processPayment ( 75.25 ); } } Abstract Classes and Polymorphism Problem Description Create an Abstract Superclass : Define an abstract class Shape with: Abstract methods calculateArea() and calculatePerimeter() . Add a String name property and a constructor to initialize it. Add a display() method to print the shape's name, area, and perimeter. Create Subclasses : Create three subclasses: Rectangle , Circle , and Triangle . Rectangle should have width and height as properties and implement the abstract methods. Circle should have radius as a property and implement the abstract methods. Triangle should support two constructors: One that takes the lengths of three sides. Another that takes the base and height. Implement method polymorphism to handle different constructors in Triangle . Main Method for Polymorphism : Create a separate class ShapeDemo with a main() method. In the main() method: Create an array or list of Shape objects containing different shapes. Demonstrate polymorphism by iterating through the collection and invoking the display() method for each shape. Code Implementation Step 1: Abstract Superclass /** * Abstract base class representing a geometric shape. * Each shape has a name and methods to calculate its area and perimeter. */ abstract class Shape { protected String name ; // Name of the shape /** * Constructor for Shape. * * @param name the name of the shape */ public Shape ( String name ) { this . name = name ; } /** * Abstract method to calculate the area of the shape. * * @return the area of the shape */ public abstract double calculateArea (); /** * Abstract method to calculate the perimeter of the shape. * * @return the perimeter of the shape */ public abstract double calculatePerimeter (); /** * Displays the name, area, and perimeter of the shape. */ public void display () { System . out . println ( \"Shape: \" + name ); System . out . println ( \"Area: \" + calculateArea ()); System . out . println ( \"Perimeter: \" + calculatePerimeter ()); System . out . println (); } } Step 2: Subclasses /** * Class representing a rectangle. * Extends the Shape class. */ class Rectangle extends Shape { private double width ; // Width of the rectangle private double height ; // Height of the rectangle /** * Constructor for Rectangle. * * @param width the width of the rectangle * @param height the height of the rectangle */ public Rectangle ( double width , double height ) { super ( \"Rectangle\" ); this . width = width ; this . height = height ; } /** * Calculates the area of the rectangle. * * @return the area of the rectangle */ @Override public double calculateArea () { return width * height ; } /** * Calculates the perimeter of the rectangle. * * @return the perimeter of the rectangle */ @Override public double calculatePerimeter () { return 2 * ( width + height ); } } /** * Class representing a circle. * Extends the Shape class. */ class Circle extends Shape { private double radius ; // Radius of the circle /** * Constructor for Circle. * * @param radius the radius of the circle */ public Circle ( double radius ) { super ( \"Circle\" ); this . radius = radius ; } /** * Calculates the area of the circle. * * @return the area of the circle */ @Override public double calculateArea () { return Math . PI * radius * radius ; } /** * Calculates the perimeter (circumference) of the circle. * * @return the perimeter of the circle */ @Override public double calculatePerimeter () { return 2 * Math . PI * radius ; } } /** * Class representing a triangle. * Extends the Shape class. */ class Triangle extends Shape { private double side1 , side2 , side3 ; // Sides of the triangle private double base , height ; // Base and height of the triangle /** * Constructor for a triangle with three sides. * * @param side1 the first side of the triangle * @param side2 the second side of the triangle * @param side3 the third side of the triangle */ public Triangle ( double side1 , double side2 , double side3 ) { super ( \"Triangle (Three Sides)\" ); this . side1 = side1 ; this . side2 = side2 ; this . side3 = side3 ; } /** * Constructor for a triangle with a base and height. * * @param base the base of the triangle * @param height the height of the triangle */ public Triangle ( double base , double height ) { super ( \"Triangle (Base and Height)\" ); this . base = base ; this . height = height ; } /** * Calculates the area of the triangle. * If base and height are provided, uses the formula: (1/2) * base * height. * If three sides are provided, uses Heron's formula. * * @return the area of the triangle */ @Override public double calculateArea () { if ( base != 0 && height != 0 ) { return 0.5 * base * height ; } else { // Heron's formula for area when all three sides are known double s = ( side1 + side2 + side3 ) / 2 ; return Math . sqrt ( s * ( s - side1 ) * ( s - side2 ) * ( s - side3 )); } } /** * Calculates the perimeter of the triangle. * Returns the sum of all sides if three sides are provided. * If only base and height are provided, perimeter is undefined. * * @return the perimeter of the triangle, or -1 if undefined */ @Override public double calculatePerimeter () { if ( side1 != 0 && side2 != 0 && side3 != 0 ) { return side1 + side2 + side3 ; } else { // Perimeter not defined for base-height triangle return - 1 ; // Returning -1 to indicate it's undefined } } } Step 3: Main Method in Separate Class /** * Demonstrates the functionality of the Shape hierarchy. * Creates various shapes, calculates their properties, and displays them. */ import java.util.ArrayList ; public class ShapeDemo { public static void main ( String [] args ) { // Create a list of shapes ArrayList < Shape > shapes = new ArrayList <> (); // Add different shape objects shapes . add ( new Rectangle ( 5 , 10 )); shapes . add ( new Circle ( 7 )); shapes . add ( new Triangle ( 3 , 4 , 5 )); shapes . add ( new Triangle ( 6 , 8 )); // Base and height triangle // Display all shapes for ( Shape shape : shapes ) { shape . display (); } } }","title":"Ch10: Improving structure with inheritance"},{"location":"Practice%20Problems/Ch10/#ch10-improving-structure-with-inheritance","text":"","title":"Ch10: Improving structure with inheritance"},{"location":"Practice%20Problems/Ch10/#casting-in-inheritance","text":"","title":"Casting in Inheritance"},{"location":"Practice%20Problems/Ch10/#problem-description","text":"Create a base class Person with attributes like name and methods like getName() . Create a subclass Student that adds attributes like studentId and methods like getStudentId() . Further extend Student with GraduateStudent , which adds attributes like researchTopic . Demonstrate: Upcasting: Casting a Student object to Person . Downcasting: Casting a Person object back to GraduateStudent safely using instanceof .","title":"Problem Description"},{"location":"Practice%20Problems/Ch10/#code-implementation","text":"class Person { private String name ; public Person ( String name ) { this . name = name ; } public String getName () { return name ; } } class Student extends Person { private int studentId ; public Student ( String name , int studentId ) { super ( name ); this . studentId = studentId ; } public int getStudentId () { return studentId ; } } class GraduateStudent extends Student { private String researchTopic ; public GraduateStudent ( String name , int studentId , String researchTopic ) { super ( name , studentId ); this . researchTopic = researchTopic ; } public String getResearchTopic () { return researchTopic ; } } public class CastingDemo { public static void main ( String [] args ) { GraduateStudent grad = new GraduateStudent ( \"Alice\" , 12345 , \"Machine Learning\" ); Person person = grad ; // Upcasting if ( person instanceof GraduateStudent ) { GraduateStudent gradStudent = ( GraduateStudent ) person ; // Downcasting System . out . println ( \"Research Topic: \" + gradStudent . getResearchTopic ()); } } }","title":"Code Implementation"},{"location":"Practice%20Problems/Ch10/#inheritance-and-collections","text":"","title":"Inheritance and Collections"},{"location":"Practice%20Problems/Ch10/#problem-description_1","text":"Create a superclass Document with a method printDetails() . Define subclasses WordDocument and Spreadsheet , each with unique attributes. Use a List<Document> to store objects of both subclasses and iterate through the list, invoking printDetails() .","title":"Problem Description"},{"location":"Practice%20Problems/Ch10/#code-implementation_1","text":"import java.util.ArrayList ; abstract class Document { protected String name ; public Document ( String name ) { this . name = name ; } public abstract void printDetails (); } class WordDocument extends Document { private int wordCount ; public WordDocument ( String name , int wordCount ) { super ( name ); this . wordCount = wordCount ; } @Override public void printDetails () { System . out . println ( \"Word Document: \" + name + \", Word Count: \" + wordCount ); } } class Spreadsheet extends Document { private int sheets ; public Spreadsheet ( String name , int sheets ) { super ( name ); this . sheets = sheets ; } @Override public void printDetails () { System . out . println ( \"Spreadsheet: \" + name + \", Sheets: \" + sheets ); } } public class DocumentDemo { public static void main ( String [] args ) { ArrayList < Document > documents = new ArrayList <> (); documents . add ( new WordDocument ( \"Report\" , 1200 )); documents . add ( new Spreadsheet ( \"Budget\" , 3 )); for ( Document doc : documents ) { doc . printDetails (); } } }","title":"Code Implementation"},{"location":"Practice%20Problems/Ch10/#method-overloading-vs-overriding","text":"","title":"Method Overloading vs. Overriding"},{"location":"Practice%20Problems/Ch10/#problem-description_2","text":"Create a Calculator class with overloaded calculate() methods: One for int arguments. Another for double arguments. Extend Calculator with a ScientificCalculator subclass, overriding calculate() to include scientific calculations.","title":"Problem Description"},{"location":"Practice%20Problems/Ch10/#code-implementation_2","text":"class Calculator { public int calculate ( int a , int b ) { return a + b ; } public double calculate ( double a , double b ) { return a + b ; } } class ScientificCalculator extends Calculator { @Override public double calculate ( double a , double b ) { return Math . pow ( a , b ); // Exponentiation } } public class CalculatorDemo { public static void main ( String [] args ) { Calculator calc = new Calculator (); System . out . println ( \"Addition (int): \" + calc . calculate ( 3 , 5 )); System . out . println ( \"Addition (double): \" + calc . calculate ( 3.2 , 5.1 )); ScientificCalculator sciCalc = new ScientificCalculator (); System . out . println ( \"Power: \" + sciCalc . calculate ( 2.0 , 3.0 )); } }","title":"Code Implementation"},{"location":"Practice%20Problems/Ch10/#deep-inheritance-hierarchies","text":"","title":"Deep Inheritance Hierarchies"},{"location":"Practice%20Problems/Ch10/#problem-description_3","text":"Create a superclass Appliance with a turnOn() method. Create a subclass KitchenAppliance with an overridden turnOn() method. Create a further subclass Toaster with additional behavior. Demonstrate method inheritance and overriding.","title":"Problem Description"},{"location":"Practice%20Problems/Ch10/#code-implementation_3","text":"class Appliance { public void turnOn () { System . out . println ( \"Appliance is now on.\" ); } } class KitchenAppliance extends Appliance { @Override public void turnOn () { System . out . println ( \"Kitchen Appliance is now on.\" ); } } class Toaster extends KitchenAppliance { public void toast () { System . out . println ( \"Toasting bread...\" ); } } public class ApplianceDemo { public static void main ( String [] args ) { Appliance appliance = new Appliance (); appliance . turnOn (); KitchenAppliance kitchenAppliance = new KitchenAppliance (); kitchenAppliance . turnOn (); Toaster toaster = new Toaster (); toaster . turnOn (); toaster . toast (); } }","title":"Code Implementation"},{"location":"Practice%20Problems/Ch10/#polymorphism-with-interfaces","text":"","title":"Polymorphism with Interfaces"},{"location":"Practice%20Problems/Ch10/#problem-description_4","text":"Define an interface Payment with a processPayment() method. Implement the interface in classes CreditCardPayment and PayPalPayment . Demonstrate polymorphism by using a Payment reference to process payments.","title":"Problem Description"},{"location":"Practice%20Problems/Ch10/#code-implementation_4","text":"interface Payment { void processPayment ( double amount ); } class CreditCardPayment implements Payment { @Override public void processPayment ( double amount ) { System . out . println ( \"Processing credit card payment of $\" + amount ); } } class PayPalPayment implements Payment { @Override public void processPayment ( double amount ) { System . out . println ( \"Processing PayPal payment of $\" + amount ); } } public class PaymentDemo { public static void main ( String [] args ) { Payment payment1 = new CreditCardPayment (); Payment payment2 = new PayPalPayment (); payment1 . processPayment ( 100.50 ); payment2 . processPayment ( 75.25 ); } }","title":"Code Implementation"},{"location":"Practice%20Problems/Ch10/#abstract-classes-and-polymorphism","text":"","title":"Abstract Classes and Polymorphism"},{"location":"Practice%20Problems/Ch10/#problem-description_5","text":"Create an Abstract Superclass : Define an abstract class Shape with: Abstract methods calculateArea() and calculatePerimeter() . Add a String name property and a constructor to initialize it. Add a display() method to print the shape's name, area, and perimeter. Create Subclasses : Create three subclasses: Rectangle , Circle , and Triangle . Rectangle should have width and height as properties and implement the abstract methods. Circle should have radius as a property and implement the abstract methods. Triangle should support two constructors: One that takes the lengths of three sides. Another that takes the base and height. Implement method polymorphism to handle different constructors in Triangle . Main Method for Polymorphism : Create a separate class ShapeDemo with a main() method. In the main() method: Create an array or list of Shape objects containing different shapes. Demonstrate polymorphism by iterating through the collection and invoking the display() method for each shape.","title":"Problem Description"},{"location":"Practice%20Problems/Ch10/#code-implementation_5","text":"Step 1: Abstract Superclass /** * Abstract base class representing a geometric shape. * Each shape has a name and methods to calculate its area and perimeter. */ abstract class Shape { protected String name ; // Name of the shape /** * Constructor for Shape. * * @param name the name of the shape */ public Shape ( String name ) { this . name = name ; } /** * Abstract method to calculate the area of the shape. * * @return the area of the shape */ public abstract double calculateArea (); /** * Abstract method to calculate the perimeter of the shape. * * @return the perimeter of the shape */ public abstract double calculatePerimeter (); /** * Displays the name, area, and perimeter of the shape. */ public void display () { System . out . println ( \"Shape: \" + name ); System . out . println ( \"Area: \" + calculateArea ()); System . out . println ( \"Perimeter: \" + calculatePerimeter ()); System . out . println (); } } Step 2: Subclasses /** * Class representing a rectangle. * Extends the Shape class. */ class Rectangle extends Shape { private double width ; // Width of the rectangle private double height ; // Height of the rectangle /** * Constructor for Rectangle. * * @param width the width of the rectangle * @param height the height of the rectangle */ public Rectangle ( double width , double height ) { super ( \"Rectangle\" ); this . width = width ; this . height = height ; } /** * Calculates the area of the rectangle. * * @return the area of the rectangle */ @Override public double calculateArea () { return width * height ; } /** * Calculates the perimeter of the rectangle. * * @return the perimeter of the rectangle */ @Override public double calculatePerimeter () { return 2 * ( width + height ); } } /** * Class representing a circle. * Extends the Shape class. */ class Circle extends Shape { private double radius ; // Radius of the circle /** * Constructor for Circle. * * @param radius the radius of the circle */ public Circle ( double radius ) { super ( \"Circle\" ); this . radius = radius ; } /** * Calculates the area of the circle. * * @return the area of the circle */ @Override public double calculateArea () { return Math . PI * radius * radius ; } /** * Calculates the perimeter (circumference) of the circle. * * @return the perimeter of the circle */ @Override public double calculatePerimeter () { return 2 * Math . PI * radius ; } } /** * Class representing a triangle. * Extends the Shape class. */ class Triangle extends Shape { private double side1 , side2 , side3 ; // Sides of the triangle private double base , height ; // Base and height of the triangle /** * Constructor for a triangle with three sides. * * @param side1 the first side of the triangle * @param side2 the second side of the triangle * @param side3 the third side of the triangle */ public Triangle ( double side1 , double side2 , double side3 ) { super ( \"Triangle (Three Sides)\" ); this . side1 = side1 ; this . side2 = side2 ; this . side3 = side3 ; } /** * Constructor for a triangle with a base and height. * * @param base the base of the triangle * @param height the height of the triangle */ public Triangle ( double base , double height ) { super ( \"Triangle (Base and Height)\" ); this . base = base ; this . height = height ; } /** * Calculates the area of the triangle. * If base and height are provided, uses the formula: (1/2) * base * height. * If three sides are provided, uses Heron's formula. * * @return the area of the triangle */ @Override public double calculateArea () { if ( base != 0 && height != 0 ) { return 0.5 * base * height ; } else { // Heron's formula for area when all three sides are known double s = ( side1 + side2 + side3 ) / 2 ; return Math . sqrt ( s * ( s - side1 ) * ( s - side2 ) * ( s - side3 )); } } /** * Calculates the perimeter of the triangle. * Returns the sum of all sides if three sides are provided. * If only base and height are provided, perimeter is undefined. * * @return the perimeter of the triangle, or -1 if undefined */ @Override public double calculatePerimeter () { if ( side1 != 0 && side2 != 0 && side3 != 0 ) { return side1 + side2 + side3 ; } else { // Perimeter not defined for base-height triangle return - 1 ; // Returning -1 to indicate it's undefined } } } Step 3: Main Method in Separate Class /** * Demonstrates the functionality of the Shape hierarchy. * Creates various shapes, calculates their properties, and displays them. */ import java.util.ArrayList ; public class ShapeDemo { public static void main ( String [] args ) { // Create a list of shapes ArrayList < Shape > shapes = new ArrayList <> (); // Add different shape objects shapes . add ( new Rectangle ( 5 , 10 )); shapes . add ( new Circle ( 7 )); shapes . add ( new Triangle ( 3 , 4 , 5 )); shapes . add ( new Triangle ( 6 , 8 )); // Base and height triangle // Display all shapes for ( Shape shape : shapes ) { shape . display (); } } }","title":"Code Implementation"},{"location":"Practice%20Problems/Ch11/","text":"Ch11 and Ch12: More about inheritance Short Problems 1. Overriding Methods Question : Consider the following classes: class Animal { public void sound () { System . out . println ( \"Animal makes a sound\" ); } } class Dog extends Animal { @Override public void sound () { System . out . println ( \"Dog barks\" ); } } Write a main method to: Create an object of type Dog and call its sound method. Create an object of type Animal but assign it a Dog instance and call the sound method. Explain the output in each case, highlighting the concept of method overriding. 2. Static vs. Dynamic Type Question : Given the code below: class Vehicle { public void displayType () { System . out . println ( \"Generic Vehicle\" ); } } class Car extends Vehicle { @Override public void displayType () { System . out . println ( \"Car\" ); } } Write a program that: Declares a variable of type Vehicle and assigns it an object of Car . Calls the displayType method on the variable. Answer the following: What is the static type of the variable? What is the dynamic type of the object the variable refers to? Which method is called at runtime and why? 3. Method Lookup Question : Examine the following class hierarchy: class Shape { public void draw () { System . out . println ( \"Drawing a Shape\" ); } } class Circle extends Shape { @Override public void draw () { System . out . println ( \"Drawing a Circle\" ); } } class Square extends Shape { @Override public void draw () { System . out . println ( \"Drawing a Square\" ); } } Write a program to: Create an array of Shape objects containing instances of Shape , Circle , and Square . Use a for loop to iterate through the array and call the draw method on each element. Explain how the method lookup process works in this case and why the correct overridden method is called for each object. 4. Polymorphism in Action Question : Consider the following class hierarchy: class Employee { public void work () { System . out . println ( \"Employee working\" ); } } class Developer extends Employee { @Override public void work () { System . out . println ( \"Developer writing code\" ); } } class Manager extends Employee { @Override public void work () { System . out . println ( \"Manager managing the team\" ); } } Write a program where: A polymorphic variable of type Employee is used to store instances of Developer and Manager . Call the work method on each object stored in the polymorphic variable. Explain how polymorphism ensures the correct method is executed at runtime. 5. Super Keyword Question : Examine the following code: class Parent { public void displayMessage () { System . out . println ( \"Message from Parent\" ); } } class Child extends Parent { @Override public void displayMessage () { System . out . println ( \"Message from Child\" ); } public void showParentMessage () { super . displayMessage (); } } Write a main method to: Create an object of type Child . Call the displayMessage method and the showParentMessage method on the object. Explain how the super keyword allows access to the overridden method in the parent class. 6. Protected Access Question : Consider the following scenario: class Person { protected String name ; public Person ( String name ) { this . name = name ; } } class Student extends Person { private int id ; public Student ( String name , int id ) { super ( name ); this . id = id ; } public void displayInfo () { System . out . println ( \"Name: \" + name + \", ID: \" + id ); } } Write a main method to create a Student object and display its information using the displayInfo method. Explain how the protected keyword allows the subclass to access the name field of the superclass. 7. Object Equality Question : Analyze the following classes: class Product { private String name ; private double price ; public Product ( String name , double price ) { this . name = name ; this . price = price ; } @Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof Product )) return false ; Product other = ( Product ) obj ; return this . name . equals ( other . name ) && this . price == other . price ; } } Write a program to: Create two Product objects with the same name and price. Compare them using both == and the equals method. Explain the difference between reference equality and content equality in the context of this example. 8. Instanceof Operator Question : Given the following classes: class Media { public void play () { System . out . println ( \"Playing generic media\" ); } } class Video extends Media { public void play () { System . out . println ( \"Playing video\" ); } public void displayResolution () { System . out . println ( \"Resolution: 1080p\" ); } } Write a program that: Declares a Media reference holding a Video object. Uses the instanceof operator to verify that the reference refers to a Video object before calling the displayResolution method. Explain how instanceof helps ensure type safety when accessing subclass-specific methods. 9. toString Method Override Question : Consider the following classes: class Book { private String title ; private String author ; public Book ( String title , String author ) { this . title = title ; this . author = author ; } @Override public String toString () { return \"Title: \" + title + \", Author: \" + author ; } } Write a program to: Create an object of the Book class. Print the object directly using System.out.println(book) . Explain how overriding the toString method affects the output of the program. 10. Overriding vs. Overloading Question : Analyze the following code: class Calculator { public int add ( int a , int b ) { return a + b ; } public double add ( double a , double b ) { return a + b ; } } class AdvancedCalculator extends Calculator { @Override public int add ( int a , int b ) { return super . add ( a , b ) + 1 ; // Adds 1 to the result } } Write a program to: Create an object of AdvancedCalculator . Call the add method for both integer and double inputs. Explain the difference between method overloading and overriding with reference to this example. Comprehensive Problem: Galaxy Explorer Simulation Design a simulation of a space exploration game where different types of spacecraft explore a galaxy. Use inheritance, polymorphism, and abstract classes to implement the system. Problem Description: Note: : As you build the simulation, you may have to add a few things to make it work the way you want it to work. For example, adding a maxrange field in the Spacecraft class maybe necessary to control how far the spacecraft can go in one turn. You will create a simulation where spacecraft explore a grid-like galaxy, collect resources, and encounter events. Each type of spacecraft will have unique behaviors, but share common functionality. Specifications: Spacecraft Superclass : Create an abstract Spacecraft class with: Fields: name (String): Name of the spacecraft. fuelLevel (int): Amount of fuel remaining. position (2D array coordinates): Current position in the galaxy. isOperational (boolean): Indicates whether the spacecraft is still functional. Concrete methods: move(int dx, int dy) : Moves the spacecraft and reduces fuel. refuel(int amount) : Refuels the spacecraft. disable() : Sets isOperational to false . Abstract method: explore(Grid grid) : To be implemented by subclasses, defining how each spacecraft explores the galaxy. Spacecraft Subclasses : MiningShip : Specializes in collecting resources. Implements explore to mine resources from its current position. BattleCruiser : Focuses on defending the galaxy. Implements explore to scan for enemy ships and engage in combat. ResearchVessel : Dedicated to scientific discoveries. Implements explore to collect data from stars or planets. Galaxy Class : Represents the galaxy grid. A 2D array of Grid objects: Grid represents each cell in the galaxy and may contain: Resources (for MiningShip). Enemy ships (for BattleCruiser). Celestial objects (for ResearchVessel). Provides methods: generateEvents() : Populates the galaxy grid with random events. getEventAt(int x, int y) : Returns the event at a specific position. SimulationManager Class : Manages the simulation: A List<Spacecraft> to hold all spacecraft. Methods: runSimulation(int steps) : Iterates through the list of spacecraft for a fixed number of steps, calling their explore methods and processing their actions. addSpacecraft(Spacecraft s) : Adds a spacecraft to the simulation. displayStatus() : Displays the status of all spacecraft. Polymorphism : Use polymorphism to manage all spacecraft in the same list. Ensure the simulation does not depend on the specific type of spacecraft when calling explore . Interfaces : Create an Event interface for all possible events in the galaxy (e.g., resources, enemy ships, celestial objects). Each event implements methods like: trigger(Spacecraft s) : Defines the event\u2019s effect on the spacecraft. Requirements: Implement the Spacecraft , MiningShip , BattleCruiser , and ResearchVessel classes. Create the Galaxy class with a 2D grid, random event generation, and event handling. Write a SimulationManager class to run the simulation and manage the spacecraft. Add events like: ResourceNode : Adds resources to a spacecraft. EnemyEncounter : Reduces fuel or disables the spacecraft if it loses. CelestialDiscovery : Provides points for research vessels. Include a main method to initialize the galaxy, populate it with spacecraft, and run the simulation. Questions: Write the complete implementation for the simulation. Analysis : Explain how polymorphism simplifies managing different types of spacecraft. Discuss the use of the abstract keyword in Spacecraft and the Event interface. Identify how interfaces provide flexibility in handling galaxy events. Extensions : Propose additional spacecraft types (e.g., CargoShip, SpyDrone) and how they could be integrated into the simulation. Discuss potential improvements, such as adding fuel management, galaxy visualization, or AI behavior for spacecraft.","title":"Ch11 and Ch12: More about inheritance"},{"location":"Practice%20Problems/Ch11/#ch11-and-ch12-more-about-inheritance","text":"","title":"Ch11 and Ch12: More about inheritance"},{"location":"Practice%20Problems/Ch11/#short-problems","text":"","title":"Short Problems"},{"location":"Practice%20Problems/Ch11/#1-overriding-methods","text":"Question : Consider the following classes: class Animal { public void sound () { System . out . println ( \"Animal makes a sound\" ); } } class Dog extends Animal { @Override public void sound () { System . out . println ( \"Dog barks\" ); } } Write a main method to: Create an object of type Dog and call its sound method. Create an object of type Animal but assign it a Dog instance and call the sound method. Explain the output in each case, highlighting the concept of method overriding.","title":"1. Overriding Methods"},{"location":"Practice%20Problems/Ch11/#2-static-vs-dynamic-type","text":"Question : Given the code below: class Vehicle { public void displayType () { System . out . println ( \"Generic Vehicle\" ); } } class Car extends Vehicle { @Override public void displayType () { System . out . println ( \"Car\" ); } } Write a program that: Declares a variable of type Vehicle and assigns it an object of Car . Calls the displayType method on the variable. Answer the following: What is the static type of the variable? What is the dynamic type of the object the variable refers to? Which method is called at runtime and why?","title":"2. Static vs. Dynamic Type"},{"location":"Practice%20Problems/Ch11/#3-method-lookup","text":"Question : Examine the following class hierarchy: class Shape { public void draw () { System . out . println ( \"Drawing a Shape\" ); } } class Circle extends Shape { @Override public void draw () { System . out . println ( \"Drawing a Circle\" ); } } class Square extends Shape { @Override public void draw () { System . out . println ( \"Drawing a Square\" ); } } Write a program to: Create an array of Shape objects containing instances of Shape , Circle , and Square . Use a for loop to iterate through the array and call the draw method on each element. Explain how the method lookup process works in this case and why the correct overridden method is called for each object.","title":"3. Method Lookup"},{"location":"Practice%20Problems/Ch11/#4-polymorphism-in-action","text":"Question : Consider the following class hierarchy: class Employee { public void work () { System . out . println ( \"Employee working\" ); } } class Developer extends Employee { @Override public void work () { System . out . println ( \"Developer writing code\" ); } } class Manager extends Employee { @Override public void work () { System . out . println ( \"Manager managing the team\" ); } } Write a program where: A polymorphic variable of type Employee is used to store instances of Developer and Manager . Call the work method on each object stored in the polymorphic variable. Explain how polymorphism ensures the correct method is executed at runtime.","title":"4. Polymorphism in Action"},{"location":"Practice%20Problems/Ch11/#5-super-keyword","text":"Question : Examine the following code: class Parent { public void displayMessage () { System . out . println ( \"Message from Parent\" ); } } class Child extends Parent { @Override public void displayMessage () { System . out . println ( \"Message from Child\" ); } public void showParentMessage () { super . displayMessage (); } } Write a main method to: Create an object of type Child . Call the displayMessage method and the showParentMessage method on the object. Explain how the super keyword allows access to the overridden method in the parent class.","title":"5. Super Keyword"},{"location":"Practice%20Problems/Ch11/#6-protected-access","text":"Question : Consider the following scenario: class Person { protected String name ; public Person ( String name ) { this . name = name ; } } class Student extends Person { private int id ; public Student ( String name , int id ) { super ( name ); this . id = id ; } public void displayInfo () { System . out . println ( \"Name: \" + name + \", ID: \" + id ); } } Write a main method to create a Student object and display its information using the displayInfo method. Explain how the protected keyword allows the subclass to access the name field of the superclass.","title":"6. Protected Access"},{"location":"Practice%20Problems/Ch11/#7-object-equality","text":"Question : Analyze the following classes: class Product { private String name ; private double price ; public Product ( String name , double price ) { this . name = name ; this . price = price ; } @Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof Product )) return false ; Product other = ( Product ) obj ; return this . name . equals ( other . name ) && this . price == other . price ; } } Write a program to: Create two Product objects with the same name and price. Compare them using both == and the equals method. Explain the difference between reference equality and content equality in the context of this example.","title":"7. Object Equality"},{"location":"Practice%20Problems/Ch11/#8-instanceof-operator","text":"Question : Given the following classes: class Media { public void play () { System . out . println ( \"Playing generic media\" ); } } class Video extends Media { public void play () { System . out . println ( \"Playing video\" ); } public void displayResolution () { System . out . println ( \"Resolution: 1080p\" ); } } Write a program that: Declares a Media reference holding a Video object. Uses the instanceof operator to verify that the reference refers to a Video object before calling the displayResolution method. Explain how instanceof helps ensure type safety when accessing subclass-specific methods.","title":"8. Instanceof Operator"},{"location":"Practice%20Problems/Ch11/#9-tostring-method-override","text":"Question : Consider the following classes: class Book { private String title ; private String author ; public Book ( String title , String author ) { this . title = title ; this . author = author ; } @Override public String toString () { return \"Title: \" + title + \", Author: \" + author ; } } Write a program to: Create an object of the Book class. Print the object directly using System.out.println(book) . Explain how overriding the toString method affects the output of the program.","title":"9. toString Method Override"},{"location":"Practice%20Problems/Ch11/#10-overriding-vs-overloading","text":"Question : Analyze the following code: class Calculator { public int add ( int a , int b ) { return a + b ; } public double add ( double a , double b ) { return a + b ; } } class AdvancedCalculator extends Calculator { @Override public int add ( int a , int b ) { return super . add ( a , b ) + 1 ; // Adds 1 to the result } } Write a program to: Create an object of AdvancedCalculator . Call the add method for both integer and double inputs. Explain the difference between method overloading and overriding with reference to this example.","title":"10. Overriding vs. Overloading"},{"location":"Practice%20Problems/Ch11/#comprehensive-problem-galaxy-explorer-simulation","text":"Design a simulation of a space exploration game where different types of spacecraft explore a galaxy. Use inheritance, polymorphism, and abstract classes to implement the system. Problem Description: Note: : As you build the simulation, you may have to add a few things to make it work the way you want it to work. For example, adding a maxrange field in the Spacecraft class maybe necessary to control how far the spacecraft can go in one turn. You will create a simulation where spacecraft explore a grid-like galaxy, collect resources, and encounter events. Each type of spacecraft will have unique behaviors, but share common functionality.","title":"Comprehensive Problem: Galaxy Explorer Simulation"},{"location":"Practice%20Problems/Ch11/#specifications","text":"Spacecraft Superclass : Create an abstract Spacecraft class with: Fields: name (String): Name of the spacecraft. fuelLevel (int): Amount of fuel remaining. position (2D array coordinates): Current position in the galaxy. isOperational (boolean): Indicates whether the spacecraft is still functional. Concrete methods: move(int dx, int dy) : Moves the spacecraft and reduces fuel. refuel(int amount) : Refuels the spacecraft. disable() : Sets isOperational to false . Abstract method: explore(Grid grid) : To be implemented by subclasses, defining how each spacecraft explores the galaxy. Spacecraft Subclasses : MiningShip : Specializes in collecting resources. Implements explore to mine resources from its current position. BattleCruiser : Focuses on defending the galaxy. Implements explore to scan for enemy ships and engage in combat. ResearchVessel : Dedicated to scientific discoveries. Implements explore to collect data from stars or planets. Galaxy Class : Represents the galaxy grid. A 2D array of Grid objects: Grid represents each cell in the galaxy and may contain: Resources (for MiningShip). Enemy ships (for BattleCruiser). Celestial objects (for ResearchVessel). Provides methods: generateEvents() : Populates the galaxy grid with random events. getEventAt(int x, int y) : Returns the event at a specific position. SimulationManager Class : Manages the simulation: A List<Spacecraft> to hold all spacecraft. Methods: runSimulation(int steps) : Iterates through the list of spacecraft for a fixed number of steps, calling their explore methods and processing their actions. addSpacecraft(Spacecraft s) : Adds a spacecraft to the simulation. displayStatus() : Displays the status of all spacecraft. Polymorphism : Use polymorphism to manage all spacecraft in the same list. Ensure the simulation does not depend on the specific type of spacecraft when calling explore . Interfaces : Create an Event interface for all possible events in the galaxy (e.g., resources, enemy ships, celestial objects). Each event implements methods like: trigger(Spacecraft s) : Defines the event\u2019s effect on the spacecraft.","title":"Specifications:"},{"location":"Practice%20Problems/Ch11/#requirements","text":"Implement the Spacecraft , MiningShip , BattleCruiser , and ResearchVessel classes. Create the Galaxy class with a 2D grid, random event generation, and event handling. Write a SimulationManager class to run the simulation and manage the spacecraft. Add events like: ResourceNode : Adds resources to a spacecraft. EnemyEncounter : Reduces fuel or disables the spacecraft if it loses. CelestialDiscovery : Provides points for research vessels. Include a main method to initialize the galaxy, populate it with spacecraft, and run the simulation.","title":"Requirements:"},{"location":"Practice%20Problems/Ch11/#questions","text":"Write the complete implementation for the simulation. Analysis : Explain how polymorphism simplifies managing different types of spacecraft. Discuss the use of the abstract keyword in Spacecraft and the Event interface. Identify how interfaces provide flexibility in handling galaxy events. Extensions : Propose additional spacecraft types (e.g., CargoShip, SpyDrone) and how they could be integrated into the simulation. Discuss potential improvements, such as adding fuel management, galaxy visualization, or AI behavior for spacecraft.","title":"Questions:"},{"location":"Practice%20Problems/Ch13/","text":"Ch13: GUI Problem 1: Classify Triangle Description : Create a Java Swing application that classifies a triangle based on the lengths of its three sides. The application should have: Three text fields for the user to enter the side lengths. A \"Classify\" button that determines the type of triangle: Equilateral, Isosceles, or Scalene. A label or dialog to display the result. (try both ways) Hints : Use JTextField for input fields and JButton for the button. Use an ActionListener for the button click event. Validate user inputs to ensure they are positive numbers. Problem 2: Zoo Admission Calculator Description : Design a Java Swing program to calculate the total admission cost for a group of zoo visitors. The GUI should include: A JTextField where the user can enter the age of a guest. A JButton to \"Add Age\" which adds the entered age to a list. A JButton to \"Calculate Total\" that computes the total admission cost based on the following rules: Age \u2264 2: Free Age 3\u201312: $14.00 Age 65+: $18.00 Others: $23.00 A label or dialog to display the total cost. Hints : - Use a JList or similar component to display the list of entered ages. - Handle empty inputs and validate the age values. Problem 3: Random Password Generator Description : Build a Java Swing application that generates a random password. The GUI should include: A \"Generate Password\" button. A label or text area to display the randomly generated password. The password should be between 7 to 10 characters long and consist of ASCII characters from 33 to 126. Hints : Use Random to generate characters and lengths. Use a JLabel or JTextArea to display the result. Problem 4: Next Prime Finder Description : Create a Java Swing application that finds the next prime number greater than a given number. The application should include: A text field for the user to input a number. A \"Find Next Prime\" button. A label or dialog to display the next prime number. Hints : Use an ActionListener to handle button clicks. Validate the input to ensure it's a positive integer.","title":"Ch13: GUI"},{"location":"Practice%20Problems/Ch13/#ch13-gui","text":"","title":"Ch13: GUI"},{"location":"Practice%20Problems/Ch13/#problem-1-classify-triangle","text":"Description : Create a Java Swing application that classifies a triangle based on the lengths of its three sides. The application should have: Three text fields for the user to enter the side lengths. A \"Classify\" button that determines the type of triangle: Equilateral, Isosceles, or Scalene. A label or dialog to display the result. (try both ways) Hints : Use JTextField for input fields and JButton for the button. Use an ActionListener for the button click event. Validate user inputs to ensure they are positive numbers.","title":"Problem 1: Classify Triangle"},{"location":"Practice%20Problems/Ch13/#problem-2-zoo-admission-calculator","text":"Description : Design a Java Swing program to calculate the total admission cost for a group of zoo visitors. The GUI should include: A JTextField where the user can enter the age of a guest. A JButton to \"Add Age\" which adds the entered age to a list. A JButton to \"Calculate Total\" that computes the total admission cost based on the following rules: Age \u2264 2: Free Age 3\u201312: $14.00 Age 65+: $18.00 Others: $23.00 A label or dialog to display the total cost. Hints : - Use a JList or similar component to display the list of entered ages. - Handle empty inputs and validate the age values.","title":"Problem 2: Zoo Admission Calculator"},{"location":"Practice%20Problems/Ch13/#problem-3-random-password-generator","text":"Description : Build a Java Swing application that generates a random password. The GUI should include: A \"Generate Password\" button. A label or text area to display the randomly generated password. The password should be between 7 to 10 characters long and consist of ASCII characters from 33 to 126. Hints : Use Random to generate characters and lengths. Use a JLabel or JTextArea to display the result.","title":"Problem 3: Random Password Generator"},{"location":"Practice%20Problems/Ch13/#problem-4-next-prime-finder","text":"Description : Create a Java Swing application that finds the next prime number greater than a given number. The application should include: A text field for the user to input a number. A \"Find Next Prime\" button. A label or dialog to display the next prime number. Hints : Use an ActionListener to handle button clicks. Validate the input to ensure it's a positive integer.","title":"Problem 4: Next Prime Finder"},{"location":"Practice%20Problems/Ch14/","text":"Ch14: Exception Handling Custom Exception Exercise: Bank Account System Question: Create a program that models a Bank Account System . Implement the following: Custom Exception : Create a custom exception class called InsufficientFundsException that inherits from Exception . This exception should: Have a constructor that accepts a message string and passes it to the superclass. BankAccount Class : Implement a BankAccount class that: Has attributes for accountHolderName (String), accountNumber (String), and balance (double). Implements a method withdraw(double amount) that: Throws InsufficientFundsException if the amount is greater than the balance . Deducts the amount from the balance otherwise. Implements a method deposit(double amount) to add the amount to the balance . BankApp Class : Create a BankApp class with a main method. Use a try-catch block to handle InsufficientFundsException when calling the withdraw method. Test the program by: Creating a BankAccount object. Depositing an initial amount. Attempting to withdraw an amount larger than the balance to trigger the custom exception. Custom Exception Exercise: Online Shopping Cart Custom Exception : Create a custom exception class called ProductOutOfStockException that inherits from Exception . This exception should: Have a constructor that accepts a message string and passes it to the superclass. Product Class : Implement a Product class that: Has attributes for productName (String), productID (String), stock (int), and price (double). Implements a method purchase(int quantity) that: Throws ProductOutOfStockException if the requested quantity is greater than stock . Deducts the quantity from the stock otherwise. ShoppingCartApp Class : Create a ShoppingCartApp class with a main method. Use a try-catch block to handle ProductOutOfStockException when calling the purchase method. Test the program by: Creating a Product object. Attempting to purchase a quantity greater than the available stock to trigger the custom exception. Miscellaneous questions on exception handling Instructions Implement the following functions with exception handling as specified. Each function must meet the outlined requirements and pass the provided test cases. Use throw statements to handle error conditions appropriately. 1. Quadratic Equation Solver Function : double[] solveQuadraticEquation(double a, double b, double c) Requirements : Calculate the real roots of ax^2 + bx + c = 0 . Return an array of roots (2 roots if the discriminant is positive, 1 if zero). Throw ArithmeticException if there are no real roots (discriminant < 0), with message \"No real roots\" . Throw IllegalArgumentException if a is zero, with message \"Coefficient 'a' cannot be zero\" . Test Cases solveQuadraticEquation(1, -3, 2) \u2192 [2.0, 1.0] solveQuadraticEquation(1, -2, 1) \u2192 [1.0] solveQuadraticEquation(1, 0, 1) \u2192 throws ArithmeticException (\"No real roots\") solveQuadraticEquation(0, 3, 2) \u2192 throws IllegalArgumentException (\"Coefficient 'a' cannot be zero\") 2. ISBN Validator and Converter Function : String convertToISBN13(String isbn10) Requirements : Convert a valid 10-digit ISBN to a 13-digit ISBN. Throw IllegalArgumentException if isbn10 is not exactly 10 characters or contains invalid characters, with message \"Invalid ISBN-10 length\" or \"ISBN-10 must be numeric or end with 'X'\" . Throw IllegalArgumentException if the ISBN-10 checksum is invalid, with message \"Invalid ISBN-10 checksum\" . Test Cases convertToISBN13(\"0306406152\") \u2192 \"9780306406157\" convertToISBN13(\"12345\") \u2192 throws IllegalArgumentException (\"Invalid ISBN-10 length\") convertToISBN13(\"03064A6152\") \u2192 throws IllegalArgumentException (\"ISBN-10 must be numeric or end with 'X'\") convertToISBN13(\"0306406151\") \u2192 throws IllegalArgumentException (\"Invalid ISBN-10 checksum\") 3. Date Validator and Parser Function : LocalDate parseDate(String dateString) Requirements : Parse dateString in \"dd-mm-yyyy\" format and return as LocalDate . Throw IllegalArgumentException if the format is incorrect, with message \"Invalid date format\" . Throw DateTimeException if the date is invalid (e.g., February 30), with message \"Invalid date value\" . Test Cases parseDate(\"15-01-2023\") \u2192 LocalDate.of(2023, 1, 15) parseDate(\"2023-01-15\") \u2192 throws IllegalArgumentException (\"Invalid date format\") parseDate(\"32-01-2023\") \u2192 throws DateTimeException (\"Invalid date value\") parseDate(\"29-02-2021\") \u2192 throws DateTimeException (\"Invalid date value\") 4. Matrix Multiplication Validator Function : int[][] multiplyMatrices(int[][] matrixA, int[][] matrixB) Requirements : Multiply matrixA and matrixB if dimensions are compatible. Throw IllegalArgumentException if matrix dimensions are incompatible, with message \"Incompatible matrices for multiplication\" . Throw IllegalArgumentException if matrices are empty, with message \"Matrices must not be empty\" . Test Cases multiplyMatrices({{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}) \u2192 {{19, 22}, {43, 50}} multiplyMatrices({{1, 2}, {3, 4}}, {{5, 6, 7}}) \u2192 throws IllegalArgumentException (\"Incompatible matrices for multiplication\") multiplyMatrices({{}}, {{}}) \u2192 throws IllegalArgumentException (\"Matrices must not be empty\") 5. File Reader with Custom Parsing Rules Function : Map<String, String> parseConfigFile(String filePath) Requirements : Read configuration file ( filePath ) with \"key=value\" format per line. Throw ParseException if any line does not contain exactly one = symbol, with message \"Line X: Invalid format\" (replace X with line number). Throw IOException if file is inaccessible, with message \"File cannot be accessed\" . Throw ParseException if a key or value is blank, with message \"Line X: Key or value cannot be blank\" . Test Cases Valid file with content: key1=value1 key2=value2 Result: { \"key1\" -> \"value1\", \"key2\" -> \"value2\" } File with line key= \u2192 throws ParseException (\"Line 2: Key or value cannot be blank\") File with line key1=value1=value2 \u2192 throws ParseException (\"Line 1: Invalid format\") Non-existent file path \u2192 throws IOException (\"File cannot be accessed\") Note : Make sure your code passes all test cases by handling exceptions properly. Each function should meet the requirements precisely as described.","title":"Ch14: Exception Handling"},{"location":"Practice%20Problems/Ch14/#ch14-exception-handling","text":"","title":"Ch14: Exception Handling"},{"location":"Practice%20Problems/Ch14/#custom-exception-exercise-bank-account-system","text":"","title":"Custom Exception Exercise: Bank Account System"},{"location":"Practice%20Problems/Ch14/#question","text":"Create a program that models a Bank Account System . Implement the following: Custom Exception : Create a custom exception class called InsufficientFundsException that inherits from Exception . This exception should: Have a constructor that accepts a message string and passes it to the superclass. BankAccount Class : Implement a BankAccount class that: Has attributes for accountHolderName (String), accountNumber (String), and balance (double). Implements a method withdraw(double amount) that: Throws InsufficientFundsException if the amount is greater than the balance . Deducts the amount from the balance otherwise. Implements a method deposit(double amount) to add the amount to the balance . BankApp Class : Create a BankApp class with a main method. Use a try-catch block to handle InsufficientFundsException when calling the withdraw method. Test the program by: Creating a BankAccount object. Depositing an initial amount. Attempting to withdraw an amount larger than the balance to trigger the custom exception.","title":"Question:"},{"location":"Practice%20Problems/Ch14/#custom-exception-exercise-online-shopping-cart","text":"Custom Exception : Create a custom exception class called ProductOutOfStockException that inherits from Exception . This exception should: Have a constructor that accepts a message string and passes it to the superclass. Product Class : Implement a Product class that: Has attributes for productName (String), productID (String), stock (int), and price (double). Implements a method purchase(int quantity) that: Throws ProductOutOfStockException if the requested quantity is greater than stock . Deducts the quantity from the stock otherwise. ShoppingCartApp Class : Create a ShoppingCartApp class with a main method. Use a try-catch block to handle ProductOutOfStockException when calling the purchase method. Test the program by: Creating a Product object. Attempting to purchase a quantity greater than the available stock to trigger the custom exception.","title":"Custom Exception Exercise: Online Shopping Cart"},{"location":"Practice%20Problems/Ch14/#miscellaneous-questions-on-exception-handling","text":"","title":"Miscellaneous questions on exception handling"},{"location":"Practice%20Problems/Ch14/#instructions","text":"Implement the following functions with exception handling as specified. Each function must meet the outlined requirements and pass the provided test cases. Use throw statements to handle error conditions appropriately.","title":"Instructions"},{"location":"Practice%20Problems/Ch14/#1-quadratic-equation-solver","text":"Function : double[] solveQuadraticEquation(double a, double b, double c) Requirements : Calculate the real roots of ax^2 + bx + c = 0 . Return an array of roots (2 roots if the discriminant is positive, 1 if zero). Throw ArithmeticException if there are no real roots (discriminant < 0), with message \"No real roots\" . Throw IllegalArgumentException if a is zero, with message \"Coefficient 'a' cannot be zero\" .","title":"1. Quadratic Equation Solver"},{"location":"Practice%20Problems/Ch14/#test-cases","text":"solveQuadraticEquation(1, -3, 2) \u2192 [2.0, 1.0] solveQuadraticEquation(1, -2, 1) \u2192 [1.0] solveQuadraticEquation(1, 0, 1) \u2192 throws ArithmeticException (\"No real roots\") solveQuadraticEquation(0, 3, 2) \u2192 throws IllegalArgumentException (\"Coefficient 'a' cannot be zero\")","title":"Test Cases"},{"location":"Practice%20Problems/Ch14/#2-isbn-validator-and-converter","text":"Function : String convertToISBN13(String isbn10) Requirements : Convert a valid 10-digit ISBN to a 13-digit ISBN. Throw IllegalArgumentException if isbn10 is not exactly 10 characters or contains invalid characters, with message \"Invalid ISBN-10 length\" or \"ISBN-10 must be numeric or end with 'X'\" . Throw IllegalArgumentException if the ISBN-10 checksum is invalid, with message \"Invalid ISBN-10 checksum\" .","title":"2. ISBN Validator and Converter"},{"location":"Practice%20Problems/Ch14/#test-cases_1","text":"convertToISBN13(\"0306406152\") \u2192 \"9780306406157\" convertToISBN13(\"12345\") \u2192 throws IllegalArgumentException (\"Invalid ISBN-10 length\") convertToISBN13(\"03064A6152\") \u2192 throws IllegalArgumentException (\"ISBN-10 must be numeric or end with 'X'\") convertToISBN13(\"0306406151\") \u2192 throws IllegalArgumentException (\"Invalid ISBN-10 checksum\")","title":"Test Cases"},{"location":"Practice%20Problems/Ch14/#3-date-validator-and-parser","text":"Function : LocalDate parseDate(String dateString) Requirements : Parse dateString in \"dd-mm-yyyy\" format and return as LocalDate . Throw IllegalArgumentException if the format is incorrect, with message \"Invalid date format\" . Throw DateTimeException if the date is invalid (e.g., February 30), with message \"Invalid date value\" .","title":"3. Date Validator and Parser"},{"location":"Practice%20Problems/Ch14/#test-cases_2","text":"parseDate(\"15-01-2023\") \u2192 LocalDate.of(2023, 1, 15) parseDate(\"2023-01-15\") \u2192 throws IllegalArgumentException (\"Invalid date format\") parseDate(\"32-01-2023\") \u2192 throws DateTimeException (\"Invalid date value\") parseDate(\"29-02-2021\") \u2192 throws DateTimeException (\"Invalid date value\")","title":"Test Cases"},{"location":"Practice%20Problems/Ch14/#4-matrix-multiplication-validator","text":"Function : int[][] multiplyMatrices(int[][] matrixA, int[][] matrixB) Requirements : Multiply matrixA and matrixB if dimensions are compatible. Throw IllegalArgumentException if matrix dimensions are incompatible, with message \"Incompatible matrices for multiplication\" . Throw IllegalArgumentException if matrices are empty, with message \"Matrices must not be empty\" .","title":"4. Matrix Multiplication Validator"},{"location":"Practice%20Problems/Ch14/#test-cases_3","text":"multiplyMatrices({{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}) \u2192 {{19, 22}, {43, 50}} multiplyMatrices({{1, 2}, {3, 4}}, {{5, 6, 7}}) \u2192 throws IllegalArgumentException (\"Incompatible matrices for multiplication\") multiplyMatrices({{}}, {{}}) \u2192 throws IllegalArgumentException (\"Matrices must not be empty\")","title":"Test Cases"},{"location":"Practice%20Problems/Ch14/#5-file-reader-with-custom-parsing-rules","text":"Function : Map<String, String> parseConfigFile(String filePath) Requirements : Read configuration file ( filePath ) with \"key=value\" format per line. Throw ParseException if any line does not contain exactly one = symbol, with message \"Line X: Invalid format\" (replace X with line number). Throw IOException if file is inaccessible, with message \"File cannot be accessed\" . Throw ParseException if a key or value is blank, with message \"Line X: Key or value cannot be blank\" .","title":"5. File Reader with Custom Parsing Rules"},{"location":"Practice%20Problems/Ch14/#test-cases_4","text":"Valid file with content: key1=value1 key2=value2 Result: { \"key1\" -> \"value1\", \"key2\" -> \"value2\" } File with line key= \u2192 throws ParseException (\"Line 2: Key or value cannot be blank\") File with line key1=value1=value2 \u2192 throws ParseException (\"Line 1: Invalid format\") Non-existent file path \u2192 throws IOException (\"File cannot be accessed\") Note : Make sure your code passes all test cases by handling exceptions properly. Each function should meet the requirements precisely as described.","title":"Test Cases"}]}